/*
 * Copyright 2022 Sue B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package k8s

import (
	"context"
	"github.com/suecodelabs/cnfuzz/src/internal/model"
	"github.com/suecodelabs/cnfuzz/src/internal/persistence"
	config3 "github.com/suecodelabs/cnfuzz/src/pkg/config"
	"github.com/suecodelabs/cnfuzz/src/pkg/k8s/util"
	"github.com/suecodelabs/cnfuzz/src/pkg/logger"
	apiv1 "k8s.io/api/core/v1"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	"time"
)

// controller that handles Kubernetes events
// if it detects a pod with an image that hasn't been fuzzed yet, it will try to fuzz the pod
type controller struct {
	log        logger.Logger
	client     kubernetes.Interface
	storage    *persistence.Storage
	config     *config3.CnFuzzConfig
	overwrites config3.Overwrites
	handleFunc func(l logger.Logger, clientSet kubernetes.Interface, storage *persistence.Storage, config *config3.CnFuzzConfig, overwrites config3.Overwrites, pod *apiv1.Pod)
}

func NewController(l logger.Logger, client kubernetes.Interface, storage *persistence.Storage, config *config3.CnFuzzConfig, overwrites config3.Overwrites) *controller {
	return &controller{
		log:        l,
		client:     client,
		storage:    storage,
		config:     config,
		overwrites: overwrites,
		handleFunc: handlePodEvent,
	}
}

func (c controller) handleEvent(pod *apiv1.Pod) {
	c.handleFunc(c.log, c.client, c.storage, c.config, c.overwrites, pod)
}

// StartController start informers that listen for Kubernetes events and let the EventHandler react on the events
func StartController(l logger.Logger, storage *persistence.Storage, config *config3.CnFuzzConfig, overwrites config3.Overwrites, client kubernetes.Interface) (err error) {
	myEventHandler := NewController(l, client, storage, config, overwrites)

	factory := informers.NewSharedInformerFactory(client, time.Hour*24)
	podInformer := factory.Core().V1().Pods().Informer()
	podInformer.AddEventHandler(myEventHandler)

	l.V(logger.InfoLevel).Info("starting to listen for events")

	stopChan := make(chan struct{})
	defer close(stopChan)
	factory.Start(stopChan)
	if !cache.WaitForCacheSync(stopChan, podInformer.HasSynced) {
		l.V(logger.ImportantLevel).Info("failed to wait for cache from cluster")
		return
	}
	select {}
}

// OnAdd handles an add event
func (c controller) OnAdd(obj any) {
	// Object types
	switch object := obj.(type) {
	case *apiv1.Pod:
		c.handleEvent(object)
	default:
		return
	}

}

// OnUpdate handles an update event
func (c controller) OnUpdate(oldObj any, newObj any) {
	switch newObject := newObj.(type) {
	case *apiv1.Pod:
		/* Could check if pod image ID changed
		oldPod := oldObj.(*apiv1.Pod)
		for _, oldStatus := range oldPod.Status.ContainerStatuses {
			for _, newStatus := range newObject.Status.ContainerStatuses {
				log.Printf("New Image ID: %s, Old image ID: %s\n", newStatus.ImageID, oldStatus.ImageID)
			}
		} */
		c.handleEvent(newObject)
	// case *apiv1.PodTemplate:
	// This could mean an entire different image or maybe just a name change
	// Fuzzer will notice any significant changes through regular Pod events
	default:
		return
	}

}

// OnDelete handles a delete event
func (c controller) OnDelete(obj any) {
	// We just ignore these completely
	// No point in fuzzing a deleted object
}

// handlePodEvent method that handles an event for a pod
// it decides if the pod needs to be fuzzed and can start the fuzzing process when the pod is ready
func handlePodEvent(l logger.Logger, client kubernetes.Interface, storage *persistence.Storage, config *config3.CnFuzzConfig, overwrites config3.Overwrites, pod *apiv1.Pod) {
	annos := GetAnnotations(&pod.ObjectMeta)

	// Skip events generated by internal Kubernetes components
	if util.IsControlPlaneObject(&pod.ObjectMeta) {
		l.V(logger.PerformanceTestLevel).Info("pod is from control plane, so not fuzzing it", "podName", pod.Name, "podNamespace", pod.Namespace)
		return
	}
	if util.IsFuzzerObject(&pod.ObjectMeta) {
		return
	}
	if annos.IgnoreMe || config.OnlyFuzzMarked && !annos.FuzzMe {
		l.V(logger.PerformanceTestLevel).Info("pod wants to be ignored, so not fuzzing it", "podName", pod.Name, "podNamespace", pod.Namespace)
		return
	}

	exists, err := util.PodExists(l, client, pod.Namespace, pod.Name)
	if err != nil {
		l.V(logger.InfoLevel).Error(err, "failed to check if pod exists, skipping this pod", "podName", pod.Name, "podNamespace", pod.Namespace)
		return
	}
	if !exists {
		l.V(logger.DebugLevel).Info("ignoring event for pod because the pod doesn't exist (anymore?)", "podName", pod.Name, "podNamespace", pod.Namespace)
		return
	}

	// Don't start until the pod is ready
	l.V(logger.DebugLevel).Info("caught event for pod", "podName", pod.Name, "podNamespace", pod.Namespace)
	l.V(logger.DebugLevel).Info("waiting until pod is in a ready state ...")

	/* TODO err := util.WaitForPodReady(client, pod, time.Minute)
	if err != nil {
		logger.Error(fmt.Errorf("failed to wait on pod %s being ready: %w", pod.Name, err).Error())
		return
	} */

	_, containsUnfuzzedImages := containsUnfuzzedImages(l, pod, storage.ContainerImageCache)
	if !containsUnfuzzedImages {
		l.V(logger.DebugLevel).Info("pod contains no images that hasn't been fuzzed yet", "podName", pod.Name, "podNamespace", pod.Namespace)
		return
	}
	l.V(logger.DebugLevel).Info("pod contains unfuzzed images", "podName", pod.Name, "podNamespace", pod.Namespace)
	// l.V(logger.InfoLevel).Info("start fuzzing pod", "podName", pod.Name)

	/* TODO singleInstance and k8s job options
	if singleInstance { */
	go StartFuzzJob(l, client, config, overwrites, pod)
	/* } else {
		startKubernetesJob()
	}*/
}

// containsUnfuzzedImages gets images from a Pod and checks inside the repository if any of the images are unknown or haven't been fuzzed earlier
func containsUnfuzzedImages(l logger.Logger, pod *apiv1.Pod, cache persistence.Cache[model.ContainerImage]) (allImages []model.ContainerImage, containsUnfuzzedImages bool) {
	// Get all images inside pod
	images, err := model.CreateContainerImagesFromPod(l, pod)
	if err != nil {
		l.V(logger.ImportantLevel).Error(err, "failed to retrieve image information from pods in service", "podName", pod.Name)
		// Skip the image
		return
	}

	// Check if there are new images
	containsUnfuzzedImages = false
	for _, image := range images {
		// Check if the image is known
		hashKey, _ := image.String()
		foundImage, found, err := cache.GetByKey(context.TODO(), hashKey)
		if err != nil {
			l.V(logger.ImportantLevel).Error(err, "error while getting image from cache")
		} else if !found {
			// The image doesn't exist yet
			containsUnfuzzedImages = true

			// Create it, and set status to being fuzzed
			image.Status = model.BeingFuzzed
			err := cache.Create(context.TODO(), image)
			if err != nil {
				l.V(logger.ImportantLevel).Error(err, "error while saving fuzzed image information inside cache")
			} else {
				// Finally, add it to our image collection for the pod that triggered the event
				allImages = append(allImages, image)
			}

		} else { // Image has already been added before
			// Check if there is still an unfuzzed version inside the pod
			if foundImage.Status == model.NotFuzzed {
				// Update the status to being fuzzed
				foundImage.Status = model.BeingFuzzed
				updateErr := cache.Update(context.TODO(), image)
				if updateErr != nil {
					l.V(logger.ImportantLevel).Error(err, "error while trying to update the status of an image inside cache to \"beingfuzzed\"", "imageHash", image.Hash)
				} else {
					containsUnfuzzedImages = true
				}
			}
			allImages = append(allImages, *foundImage)
		}
	}
	return allImages, containsUnfuzzedImages
}
